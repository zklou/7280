<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>powerlaw &#8212; powerlaw 1.4.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for powerlaw</h1><div class="highlight"><pre>
<span></span><span class="c1">#The MIT License (MIT)</span>
<span class="c1">#</span>
<span class="c1">#Copyright (c) 2013-2017 Jeff Alstott</span>
<span class="c1">#</span>
<span class="c1">#Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1">#of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1">#in the Software without restriction, including without limitation the rights</span>
<span class="c1">#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1">#copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1">#furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1">#The above copyright notice and this permission notice shall be included in</span>
<span class="c1">#all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1">#THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1">#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1">#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1">#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1">#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1">#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="c1">#THE SOFTWARE.</span>

<span class="c1"># as described in https://docs.python.org/2/library/functions.html#print</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.4.3&quot;</span>

<div class="viewcode-block" id="Fit"><a class="viewcode-back" href="../index.html#powerlaw.Fit">[docs]</a><span class="k">class</span> <span class="nc">Fit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fit of a data set to various probability distributions, namely power</span>
<span class="sd">    laws. For fits to power laws, the methods of Clauset et al. 2007 are used.</span>
<span class="sd">    These methods identify the portion of the tail of the distribution that</span>
<span class="sd">    follows a power law, beyond a value xmin. If no xmin is</span>
<span class="sd">    provided, the optimal one is calculated and assigned at initialization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array</span>
<span class="sd">    discrete : boolean, optional</span>
<span class="sd">        Whether the data is discrete (integers).</span>
<span class="sd">    xmin : int or float, optional</span>
<span class="sd">        The data value beyond which distributions should be fitted. If</span>
<span class="sd">        None an optimal one will be calculated.</span>
<span class="sd">    xmax : int or float, optional</span>
<span class="sd">        The maximum value of the fitted distributions.</span>
<span class="sd">    verbose: bool, optional</span>
<span class="sd">        Whether to print updates about where we are in the fitting process.</span>
<span class="sd">        Default True.</span>
<span class="sd">    estimate_discrete : bool, optional</span>
<span class="sd">        Whether to estimate the fit of a discrete power law using fast</span>
<span class="sd">        analytical methods, instead of calculating the fit exactly with</span>
<span class="sd">        slow numerical methods. Very accurate with xmin&gt;6</span>
<span class="sd">    sigma_threshold : float, optional</span>
<span class="sd">        Upper limit on the standard error of the power law fit. Used after</span>
<span class="sd">        fitting, when identifying valid xmin values.</span>
<span class="sd">    parameter_range : dict, optional</span>
<span class="sd">        Dictionary of valid parameter ranges for fitting. Formatted as a</span>
<span class="sd">        dictionary of parameter names (&#39;alpha&#39; and/or &#39;sigma&#39;) and tuples</span>
<span class="sd">        of their lower and upper limits (ex. (1.5, 2.5), (None, .1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                 <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">fit_method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span>
                 <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">discrete_approximation</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                 <span class="n">sigma_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parameter_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fit_optimizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">xmin_distance</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># import logging</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">asarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_original</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="o">=</span> <span class="n">discrete</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="n">fit_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span> <span class="o">=</span> <span class="n">estimate_discrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span> <span class="o">=</span> <span class="n">discrete_approximation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_threshold</span> <span class="o">=</span> <span class="n">sigma_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_range</span> <span class="o">=</span> <span class="n">parameter_range</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">given_xmin</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">given_xmax</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_xmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_xmax</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xmin_distance</span> <span class="o">=</span> <span class="n">xmin_distance</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Values less than or equal to 0 in data. Throwing out 0 or negative values&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xmax</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">n_above_max</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_above_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xmax</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sort</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitting_cdf_bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_cdf</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xmin</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span><span class="o">!=</span><span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span><span class="o">!=</span><span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xmin</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">pl</span> <span class="o">=</span> <span class="n">Power_Law</span><span class="p">(</span><span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span>
                           <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                           <span class="n">discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">,</span>
                           <span class="n">fit_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="p">,</span>
                           <span class="n">estimate_discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span><span class="p">,</span>
                           <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                           <span class="n">parameter_range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_range</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin_distance</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin_distance</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">sigma</span>
            <span class="c1">#self.power_law = pl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xmin</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating best minimal value for power law fit&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_xmin</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">n_above_max</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">supported_distributions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;power_law&#39;</span><span class="p">:</span> <span class="n">Power_Law</span><span class="p">,</span>
                                        <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span> <span class="n">Lognormal</span><span class="p">,</span>
                                        <span class="s1">&#39;exponential&#39;</span><span class="p">:</span> <span class="n">Exponential</span><span class="p">,</span>
                                        <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">:</span> <span class="n">Truncated_Power_Law</span><span class="p">,</span>
                                        <span class="s1">&#39;stretched_exponential&#39;</span><span class="p">:</span> <span class="n">Stretched_Exponential</span><span class="p">,</span>
                                        <span class="s1">&#39;lognormal_positive&#39;</span><span class="p">:</span> <span class="n">Lognormal_Positive</span><span class="p">,</span>
                                        <span class="p">}</span>
                                        <span class="c1">#&#39;gamma&#39;: None}</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_distributions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#from string import capwords</span>
            <span class="c1">#dist = capwords(name, &#39;_&#39;)</span>
            <span class="c1">#dist = globals()[dist] #Seems a hack. Might try import powerlaw; getattr(powerlaw, dist)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_distributions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="n">Power_Law</span><span class="p">:</span>
                <span class="n">parameter_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameter_range</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">dist</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                         <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span>
                         <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                         <span class="n">discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">,</span>
                         <span class="n">fit_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="p">,</span>
                         <span class="n">estimate_discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span><span class="p">,</span>
                         <span class="n">discrete_approximation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span><span class="p">,</span>
                         <span class="n">parameter_range</span><span class="o">=</span><span class="n">parameter_range</span><span class="p">,</span>
                         <span class="n">parent_Fit</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Fit.find_xmin"><a class="viewcode-back" href="../index.html#powerlaw.Fit.find_xmin">[docs]</a>    <span class="k">def</span> <span class="nf">find_xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the optimal xmin beyond which the scaling regime of the power</span>
<span class="sd">        law fits best. The attribute self.xmin of the Fit object is also set.</span>

<span class="sd">        The optimal xmin beyond which the scaling regime of the power law fits</span>
<span class="sd">        best is identified by minimizing the Kolmogorov-Smirnov distance</span>
<span class="sd">        between the data and the theoretical power law fit.</span>
<span class="sd">        This is the method of Clauset et al. 2007.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">unique</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">argmin</span>
<span class="c1">#Much of the rest of this function was inspired by Adam Ginsburg&#39;s plfit code,</span>
<span class="c1">#specifically the mapping and sigma threshold behavior:</span>
<span class="c1">#http://code.google.com/p/agpy/source/browse/trunk/plfit/plfit.py?spec=svn359&amp;r=357</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">given_xmin</span><span class="p">:</span>
            <span class="n">possible_xmins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possible_ind</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_xmin</span><span class="p">)</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">possible_ind</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">&lt;=</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">given_xmin</span><span class="p">)</span>
            <span class="n">possible_xmins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">possible_ind</span><span class="p">]</span>
        <span class="n">xmins</span><span class="p">,</span> <span class="n">xmin_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">possible_xmins</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#Don&#39;t look at last xmin, as that&#39;s also the xmax, and we want to at least have TWO points to fit!</span>
        <span class="n">xmins</span> <span class="o">=</span> <span class="n">xmins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xmin_indices</span> <span class="o">=</span> <span class="n">xmin_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xmin_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xmin_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin_distance</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xmins</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Less than 2 unique data values left after xmin and xmax &quot;</span>
                  <span class="s2">&quot;options! Cannot fit. Returning nans.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">nan</span><span class="p">,</span> <span class="n">array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Asquare</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Kappa</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_tail</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_ranges</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmins</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>

        <span class="k">def</span> <span class="nf">fit_function</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
            <span class="n">pl</span> <span class="o">=</span> <span class="n">Power_Law</span><span class="p">(</span><span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span>
                           <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                           <span class="n">discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">,</span>
                           <span class="n">estimate_discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span><span class="p">,</span>
                           <span class="n">fit_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="p">,</span>
                           <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                           <span class="n">parameter_range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_range</span><span class="p">,</span>
                           <span class="n">parent_Fit</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pl</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="p">),</span> <span class="n">pl</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">pl</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span>

        <span class="n">fits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fit_function</span><span class="p">,</span> <span class="n">xmins</span><span class="p">)))</span>
        <span class="c1"># logging.warning(fits.shape)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">fits</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_ranges</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmins</span> <span class="o">=</span> <span class="n">xmins</span>

        <span class="n">good_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_ranges</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_threshold</span><span class="p">:</span>
            <span class="n">good_values</span> <span class="o">=</span> <span class="n">good_values</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">good_values</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">good_values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="k">import</span> <span class="n">masked_array</span>
            <span class="n">masked_Ds</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">),</span> <span class="n">mask</span><span class="o">=-</span><span class="n">good_values</span><span class="p">)</span>
            <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">masked_Ds</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid fits found.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

        <span class="c1">#Set the Fit&#39;s xmin to the optimal xmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">xmins</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin_distance</span><span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">)[</span><span class="n">min_D_index</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>

        <span class="c1">#Update the fitting CDF given the new xmin, in case other objects, like</span>
        <span class="c1">#Distributions, want to use it for fitting (like if they do KS fitting)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitting_cdf_bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span></div>


<div class="viewcode-block" id="Fit.nested_distribution_compare"><a class="viewcode-back" href="../index.html#powerlaw.Fit.nested_distribution_compare">[docs]</a>    <span class="k">def</span> <span class="nf">nested_distribution_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the loglikelihood ratio, and its p-value, between the two</span>
<span class="sd">        distribution fits, assuming the candidate distributions are nested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist1 : string</span>
<span class="sd">            Name of the first candidate distribution (ex. &#39;power_law&#39;)</span>
<span class="sd">        dist2 : string</span>
<span class="sd">            Name of the second candidate distribution (ex. &#39;exponential&#39;)</span>
<span class="sd">        nested : bool or None, optional</span>
<span class="sd">            Whether to assume the candidate distributions are nested versions</span>
<span class="sd">            of each other. None assumes not unless the name of one distribution</span>
<span class="sd">            is a substring of the other. True by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : float</span>
<span class="sd">            Loglikelihood ratio of the two distributions&#39; fit to the data. If</span>
<span class="sd">            greater than 0, the first distribution is preferred. If less than</span>
<span class="sd">            0, the second distribution is preferred.</span>
<span class="sd">        p : float</span>
<span class="sd">            Significance of R</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_compare</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.distribution_compare"><a class="viewcode-back" href="../index.html#powerlaw.Fit.distribution_compare">[docs]</a>    <span class="k">def</span> <span class="nf">distribution_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the loglikelihood ratio, and its p-value, between the two</span>
<span class="sd">        distribution fits, assuming the candidate distributions are nested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist1 : string</span>
<span class="sd">            Name of the first candidate distribution (ex. &#39;power_law&#39;)</span>
<span class="sd">        dist2 : string</span>
<span class="sd">            Name of the second candidate distribution (ex. &#39;exponential&#39;)</span>
<span class="sd">        nested : bool or None, optional</span>
<span class="sd">            Whether to assume the candidate distributions are nested versions</span>
<span class="sd">            of each other. None assumes not unless the name of one distribution</span>
<span class="sd">            is a substring of the other.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : float</span>
<span class="sd">            Loglikelihood ratio of the two distributions&#39; fit to the data. If</span>
<span class="sd">            greater than 0, the first distribution is preferred. If less than</span>
<span class="sd">            0, the second distribution is preferred.</span>
<span class="sd">        p : float</span>
<span class="sd">            Significance of R</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist1</span> <span class="ow">in</span> <span class="n">dist2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dist2</span> <span class="ow">in</span> <span class="n">dist1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nested</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assuming nested distributions&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">nested</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">dist1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist1</span><span class="p">)</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>

        <span class="n">loglikelihoods1</span> <span class="o">=</span> <span class="n">dist1</span><span class="o">.</span><span class="n">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">loglikelihoods2</span> <span class="o">=</span> <span class="n">dist2</span><span class="o">.</span><span class="n">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loglikelihood_ratio</span><span class="p">(</span>
            <span class="n">loglikelihoods1</span><span class="p">,</span> <span class="n">loglikelihoods2</span><span class="p">,</span>
            <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.loglikelihood_ratio"><a class="viewcode-back" href="../index.html#powerlaw.Fit.loglikelihood_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">loglikelihood_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Another name for distribution_compare.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution_compare</span><span class="p">(</span><span class="n">dist1</span><span class="p">,</span> <span class="n">dist2</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.cdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cumulative distribution function of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to return the complementary cumulative distribution</span>
<span class="sd">            function, 1-CDF, also known as the survival function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X : array</span>
<span class="sd">            The sorted, unique values in the data.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is less than or equal to X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>
        <span class="k">return</span> <span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.ccdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.ccdf">[docs]</a>    <span class="k">def</span> <span class="nf">ccdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the complementary cumulative distribution function of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to return the complementary cumulative distribution</span>
<span class="sd">            function, also known as the survival function, or the cumulative</span>
<span class="sd">            distribution function, 1-CCDF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X : array</span>
<span class="sd">            The sorted, unique values in the data.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is greater than or equal to X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>
        <span class="k">return</span> <span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.pdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the probability density function (normalized histogram) of the</span>
<span class="sd">        data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_edges : array</span>
<span class="sd">            The edges of the bins of the probability density function.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is within the bin. Length 1 less than</span>
<span class="sd">            bin_edges, as it corresponds to the spaces between them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>
        <span class="n">edges</span><span class="p">,</span> <span class="n">hist</span> <span class="o">=</span> <span class="n">pdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">,</span> <span class="n">hist</span></div>

<div class="viewcode-block" id="Fit.plot_cdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.plot_cdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the CDF to a new figure or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to plot a CDF (False) or CCDF (True). False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">plot_cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.plot_ccdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.plot_ccdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ccdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the CCDF to a new figure or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to plot a CDF (False) or CCDF (True). True by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">plot_cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.plot_pdf"><a class="viewcode-back" href="../index.html#powerlaw.Fit.plot_pdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">linear_bins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the probability density function (PDF) or the data to a new figure</span>
<span class="sd">        or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">        original_data : bool, optional</span>
<span class="sd">            Whether to use all of the data initially passed to the Fit object.</span>
<span class="sd">            If False, uses only the data used for the fit (within xmin and</span>
<span class="sd">            xmax.)</span>
<span class="sd">        linear_bins : bool, optional</span>
<span class="sd">            Whether to use linearly spaced bins (True) or logarithmically</span>
<span class="sd">            spaced bins (False). False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">original_data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">plot_pdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">linear_bins</span><span class="o">=</span><span class="n">linear_bins</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Distribution"><a class="viewcode-back" href="../index.html#powerlaw.Distribution">[docs]</a><span class="k">class</span> <span class="nc">Distribution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract class for theoretical probability distributions. Can be created</span>
<span class="sd">    with particular parameter values, or fitted to a dataset. Fitting is</span>
<span class="sd">    by maximum likelihood estimation by default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xmin : int or float, optional</span>
<span class="sd">        The data value beyond which distributions should be fitted. If</span>
<span class="sd">        None an optimal one will be calculated.</span>
<span class="sd">    xmax : int or float, optional</span>
<span class="sd">        The maximum value of the fitted distributions.</span>
<span class="sd">    discrete : boolean, optional</span>
<span class="sd">        Whether the distribution is discrete (integers).</span>

<span class="sd">    data : list or array, optional</span>
<span class="sd">        The data to which to fit the distribution. If provided, the fit will</span>
<span class="sd">        be created at initialization.</span>
<span class="sd">    fit_method : &quot;Likelihood&quot; or &quot;KS&quot;, optional</span>
<span class="sd">        Method for fitting the distribution. &quot;Likelihood&quot; is maximum Likelihood</span>
<span class="sd">        estimation. &quot;KS&quot; is minimial distance estimation using The</span>
<span class="sd">        Kolmogorov-Smirnov test.</span>

<span class="sd">    parameters : tuple or list, optional</span>
<span class="sd">        The parameters of the distribution. Will be overridden if data is</span>
<span class="sd">        given or the fit method is called.</span>
<span class="sd">    parameter_range : dict, optional</span>
<span class="sd">        Dictionary of valid parameter ranges for fitting. Formatted as a</span>
<span class="sd">        dictionary of parameter names (&#39;alpha&#39; and/or &#39;sigma&#39;) and tuples</span>
<span class="sd">        of their lower and upper limits (ex. (1.5, 2.5), (None, .1)</span>
<span class="sd">    initial_parameters : tuple or list, optional</span>
<span class="sd">        Initial values for the parameter in the fitting search.</span>

<span class="sd">    discrete_approximation : &quot;round&quot;, &quot;xmax&quot; or int, optional</span>
<span class="sd">        If the discrete form of the theoeretical distribution is not known,</span>
<span class="sd">        it can be estimated. One estimation method is &quot;round&quot;, which sums</span>
<span class="sd">        the probability mass from x-.5 to x+.5 for each data point. The other</span>
<span class="sd">        option is to calculate the probability for each x from 1 to N and</span>
<span class="sd">        normalize by their sum. N can be &quot;xmax&quot; or an integer.</span>

<span class="sd">    parent_Fit : Fit object, optional</span>
<span class="sd">        A Fit object from which to use data, if it exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">xmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fit_method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span>
                 <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parameter_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">discrete_approximation</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                 <span class="n">parent_Fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="o">=</span> <span class="n">discrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="n">fit_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span> <span class="o">=</span> <span class="n">discrete_approximation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter3</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter3_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">parent_Fit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span> <span class="o">=</span> <span class="n">parent_Fit</span>

        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parameter_range</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_range</span><span class="p">(</span><span class="n">parameter_range</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_given_initial_parameters</span><span class="p">(</span><span class="n">initial_parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parameter_range</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<div class="viewcode-block" id="Distribution.fit"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the parameters of the distribution to the data. Uses options set</span>
<span class="sd">        at initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="o">==</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fit_function</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span><span class="o">==</span><span class="s1">&#39;KS&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fit_function</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">KS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin</span>
        <span class="n">parameters</span><span class="p">,</span> <span class="n">negative_loglikelihood</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span><span class="p">,</span> <span class="o">=</span> \
            <span class="n">fmin</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_parameters</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">suppress_output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid fits found.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood</span> <span class="o">=-</span><span class="n">negative_loglikelihood</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.KS"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.KS">[docs]</a>    <span class="k">def</span> <span class="nf">KS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Kolmogorov-Smirnov distance D between the distribution and</span>
<span class="sd">        the data. Also sets the properties D+, D-, V (the Kuiper testing</span>
<span class="sd">        statistic), and Kappa (1 + the average difference between the</span>
<span class="sd">        theoretical and empirical distributions).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not enough data. Returning nan&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D_plus</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D_minus</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Kappa</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Asquare</span> <span class="o">=</span> <span class="n">nan</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

        <span class="k">if</span>  <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">fitting_cdf_bins</span>
            <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">fitting_cdf</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">bins</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="n">Actual_CDF</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">dropped_probability</span> <span class="o">=</span> <span class="n">Actual_CDF</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Actual_CDF</span> <span class="o">-=</span> <span class="n">dropped_probability</span>
            <span class="n">Actual_CDF</span> <span class="o">/=</span> <span class="mi">1</span><span class="o">-</span><span class="n">dropped_probability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bins</span><span class="p">,</span> <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">Theoretical_CDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

        <span class="n">CDF_diff</span> <span class="o">=</span> <span class="n">Theoretical_CDF</span> <span class="o">-</span> <span class="n">Actual_CDF</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">D_plus</span> <span class="o">=</span> <span class="n">CDF_diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_minus</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">CDF_diff</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Kappa</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mean</span><span class="p">(</span><span class="n">CDF_diff</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_plus</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_minus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_minus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Asquare</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span>
                            <span class="p">(</span><span class="n">CDF_diff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                            <span class="p">(</span><span class="n">Theoretical_CDF</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Theoretical_CDF</span><span class="p">))</span>
                            <span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
                           <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span></div>

<div class="viewcode-block" id="Distribution.ccdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.ccdf">[docs]</a>    <span class="k">def</span> <span class="nf">ccdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The complementary cumulative distribution function (CCDF) of the</span>
<span class="sd">        theoretical distribution. Calculated for the values given in data</span>
<span class="sd">        within xmin and xmax, if present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to calculate a CDF (False) or CCDF (True).</span>
<span class="sd">            True by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X : array</span>
<span class="sd">            The sorted, unique values in the data.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is less than or equal to X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.cdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cumulative distribution function (CDF) of the theoretical</span>
<span class="sd">        distribution. Calculated for the values given in data within xmin and</span>
<span class="sd">        xmax, if present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to calculate a CDF (False) or CCDF (True).</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X : array</span>
<span class="sd">            The sorted, unique values in the data.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is less than or equal to X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
<span class="c1">#If cdf_xmin is 1, it means we don&#39;t have the numerical accuracy to</span>
            <span class="c1">#calculate this tail. So we make everything 1, indicating</span>
            <span class="c1">#we&#39;re at the end of the tail. Such an xmin should be thrown</span>
            <span class="c1">#out by the KS test.</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ones</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CDF</span>

        <span class="n">CDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">))</span>

        <span class="n">CDF</span> <span class="o">=</span> <span class="n">CDF</span><span class="o">/</span><span class="n">norm</span>

        <span class="k">if</span> <span class="n">survival</span><span class="p">:</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">CDF</span>

        <span class="n">possible_numerical_error</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">isnan</span><span class="p">,</span> <span class="nb">min</span>
        <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">CDF</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;nan&#39; in fit cumulative distribution values.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">possible_numerical_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#if 0 in CDF or 1 in CDF:</span>
        <span class="c1">#    print(&quot;0 or 1 in fit cumulative distribution values.&quot;, file=sys.stderr)</span>
        <span class="c1">#    possible_numerical_error = True</span>
        <span class="k">if</span> <span class="n">possible_numerical_error</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Likely underflow or overflow error: the optimal fit for this distribution gives values that are so extreme that we lack the numerical precision to calculate them.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CDF</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdf_xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>


<div class="viewcode-block" id="Distribution.pdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the probability density function (normalized histogram) of the</span>
<span class="sd">        theoretical distribution for the values in data within xmin and xmax,</span>
<span class="sd">        if present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        probabilities : array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_continuous_normalizer</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">C</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_discrete_normalizer</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_discrete_normalizer</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">C</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span><span class="o">==</span><span class="s1">&#39;round&#39;</span><span class="p">:</span>
                <span class="n">lower_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">-.</span><span class="mi">5</span>
                <span class="n">upper_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">+.</span><span class="mi">5</span>
<span class="c1">#Temporarily expand xmin and xmax to be able to grab the extra bit of</span>
<span class="c1">#probability mass beyond the (integer) values of xmin and xmax</span>
<span class="c1">#Note this is a design decision. One could also say this extra</span>
<span class="c1">#probability &quot;off the edge&quot; of the distribution shouldn&#39;t be included,</span>
<span class="c1">#and that implementation is retained below, commented out. Note, however,</span>
<span class="c1">#that such a cliff means values right at xmin and xmax have half the width to</span>
<span class="c1">#grab probability from, and thus are lower probability than they would otherwise</span>
<span class="c1">#be. This is particularly concerning for values at xmin, which are typically</span>
<span class="c1">#the most likely and greatly influence the distribution&#39;s fit.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-=</span> <span class="o">.</span><span class="mi">5</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">5</span>
                <span class="c1">#Clean data for invalid values before handing to cdf, which will purge them</span>
                <span class="c1">#lower_data[lower_data&lt;self.xmin] +=.5</span>
                <span class="c1">#if self.xmax:</span>
                <span class="c1">#    upper_data[upper_data&gt;self.xmax] -=.5</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">upper_data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lower_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+=.</span><span class="mi">5</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-=</span> <span class="o">.</span><span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span><span class="o">==</span><span class="s1">&#39;xmax&#39;</span><span class="p">:</span>
                    <span class="n">upper_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">upper_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span>
<span class="c1">#            from mpmath import exp</span>
                <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">upper_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">PDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDF</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
        <span class="k">return</span> <span class="n">likelihoods</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Distribution.parameter_range"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.parameter_range">[docs]</a>    <span class="k">def</span> <span class="nf">parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the limits on the range of valid parameters to be considered while</span>
<span class="sd">        fitting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : dict</span>
<span class="sd">            A dictionary of the parameter range. Restricted parameter</span>
<span class="sd">            names are keys, and with tuples of the form (lower_bound,</span>
<span class="sd">            upper_bound) as values.</span>
<span class="sd">        initial_parameters : tuple or list, optional</span>
<span class="sd">            Initial parameter values to start the fitting search from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">FunctionType</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">==</span><span class="n">FunctionType</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_given_parameter_range</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_dict</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">if</span> <span class="n">initial_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_given_initial_parameters</span> <span class="o">=</span> <span class="n">initial_parameters</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.in_range"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.in_range">[docs]</a>    <span class="k">def</span> <span class="nf">in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the current parameters of the distribution are within the range</span>
<span class="sd">        of valid parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_dict</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="c1">#For any attributes we&#39;ve specificed, make sure we&#39;re above the lower bound</span>
<span class="c1">#and below the lower bound (if they exist). This must be true of all of them.</span>
                <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">upper_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">*=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">upper_bound</span>
                <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">*=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lower_bound</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">in_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_given_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">in_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_standard_parameter_range</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">in_range</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.initial_parameters"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.initial_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return previously user-provided initial parameters or, if never</span>
<span class="sd">        provided,  calculate new ones. Default initial parameter estimates are</span>
<span class="sd">        unique to each theoretical distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_given_initial_parameters</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_parameters</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.likelihoods"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.likelihoods">[docs]</a>    <span class="k">def</span> <span class="nf">likelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The likelihoods of the observed data from the theoretical distribution.</span>
<span class="sd">        Another name for the probabilities or probability density function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.loglikelihoods"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.loglikelihoods">[docs]</a>    <span class="k">def</span> <span class="nf">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The logarithm of the likelihoods of the observed data from the</span>
<span class="sd">        theoretical distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">))</span></div>

<div class="viewcode-block" id="Distribution.plot_ccdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.plot_ccdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ccdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the complementary cumulative distribution function (CDF) of the</span>
<span class="sd">        theoretical distribution for the values given in data within xmin and</span>
<span class="sd">        xmax, if present. Plots to a new figure or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to plot a CDF (False) or CCDF (True). True by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Distribution.plot_cdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.plot_cdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the cumulative distribution function (CDF) of the</span>
<span class="sd">        theoretical distribution for the values given in data within xmin and</span>
<span class="sd">        xmax, if present. Plots to a new figure or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to plot a CDF (False) or CCDF (True). False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">unique</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">))</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">CDF</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Distribution.plot_pdf"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.plot_pdf">[docs]</a>    <span class="k">def</span> <span class="nf">plot_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the probability density function (PDF) of the</span>
<span class="sd">        theoretical distribution for the values given in data within xmin and</span>
<span class="sd">        xmax, if present. Plots to a new figure or to axis ax if provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        ax : matplotlib axis, optional</span>
<span class="sd">            The axis to which to plot. If None, a new figure is created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib axis</span>
<span class="sd">            The axis to which the plot was made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">unique</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">))</span>
        <span class="n">PDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">nan</span>
        <span class="n">PDF</span><span class="p">[</span><span class="n">PDF</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">PDF</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">PDF</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Distribution.generate_random"><a class="viewcode-back" href="../index.html#powerlaw.Distribution.generate_random">[docs]</a>    <span class="k">def</span> <span class="nf">generate_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates random numbers from the theoretical probability distribution.</span>
<span class="sd">        If xmax is present, it is currently ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int or float</span>
<span class="sd">            The number of random numbers to generate</span>
<span class="sd">        estimate_discrete : boolean</span>
<span class="sd">            For discrete distributions, whether to use a faster approximation of</span>
<span class="sd">            the random number generator. If None, attempts to inherit</span>
<span class="sd">            the estimate_discrete behavior used for fitting from the Distribution</span>
<span class="sd">            object or the parent Fit object, if present. Approximations only</span>
<span class="sd">            exist for some distributions (namely the power law). If an</span>
<span class="sd">            approximation does not exist an estimate_discrete setting of True</span>
<span class="sd">            will not be inherited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r : array</span>
<span class="sd">            Random numbers drawn from the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">rand</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_random_continuous</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">estimate_discrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_generate_random_discrete_estimate&#39;</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;This distribution does not have an &quot;</span>
                                     <span class="s2">&quot;estimation of the discrete form for generating simulated &quot;</span>
                                     <span class="s2">&quot;data. Try the exact form with estimate_discrete=False.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">estimate_discrete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_generate_random_discrete_estimate&#39;</span><span class="p">):</span>
                    <span class="n">estimate_discrete</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;estimate_discrete&#39;</span><span class="p">):</span>
                    <span class="n">estimate_discrete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
                    <span class="n">estimate_discrete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">estimate_discrete</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">estimate_discrete</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">estimate_discrete</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_random_discrete_estimate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_double_search_discrete</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">r</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_double_search_discrete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1">#Find a range from x1 to x2 that our random probability fits between</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">ccdf</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">x2</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span>
        <span class="c1">#Use binary search within that range to find the exact answer, up to</span>
        <span class="c1">#the limit of being between two integers.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">bisect_map</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ccdf</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<span class="k">class</span> <span class="nc">Power_Law</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span> <span class="o">=</span> <span class="n">estimate_discrete</span>
        <span class="n">Distribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="s1">&#39;alpha&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;power_law&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1">#Only is calculable after self.fit is started, when the number of data points is</span>
<span class="c1">#established</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sqrt</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">&gt;</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="nb">sum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
                <span class="n">Distribution</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">suppress_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">KS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">))))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
                <span class="n">Distribution</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">suppress_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">KS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Distribution</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">suppress_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_flag</span><span class="o">=</span><span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="nb">sum</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">zeta</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">zeta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="c1">#Can this be reformulated to not reference xmin? Removal of the probability</span>
<span class="c1">#before xmin and after xmax is handled in Distribution.cdf(), so we don&#39;t</span>
<span class="c1">#strictly need this element. It doesn&#39;t hurt, for the moment.</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CDF</span>

    <span class="k">def</span> <span class="nf">_pdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">**-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">_generate_random_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">_generate_random_discrete_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">around</span>
            <span class="k">return</span> <span class="n">around</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Exponential</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="s1">&#39;lambda&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;exponential&quot;</span>

    <span class="k">def</span> <span class="nf">_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">&gt;</span><span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CDF</span>

    <span class="k">def</span> <span class="nf">_pdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">))</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">Cxmax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">))</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Cxmax</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
<span class="c1">#        likelihoods = exp(-Lambda*data)*\</span>
<span class="c1">#                Lambda*exp(Lambda*xmin)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="n">data</span><span class="p">))</span>
            <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">likelihoods</span>

    <span class="k">def</span> <span class="nf">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
<span class="c1">#        likelihoods = exp(-Lambda*data)*\</span>
<span class="c1">#                Lambda*exp(Lambda*xmin)</span>
            <span class="n">loglikelihoods</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="n">data</span><span class="p">))</span>
            <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="n">loglikelihoods</span><span class="p">[</span><span class="n">loglikelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loglikelihoods</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loglikelihoods</span>

    <span class="k">def</span> <span class="nf">_generate_random_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Stretched_Exponential</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="s1">&#39;lambda&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span> <span class="o">=</span> <span class="s1">&#39;beta&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;stretched_exponential&quot;</span>

    <span class="k">def</span> <span class="nf">_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">&gt;</span><span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CDF</span>

    <span class="k">def</span> <span class="nf">_pdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="k">return</span> <span class="p">(((</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span>
                <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">exp</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span>
                           <span class="n">exp</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">-</span>
                               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">))</span>
            <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">likelihoods</span>

    <span class="k">def</span> <span class="nf">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
            <span class="n">loglikelihoods</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">log</span><span class="p">((</span><span class="n">data</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span> <span class="n">Lambda</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">-</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
            <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">inf</span>
            <span class="n">loglikelihoods</span><span class="p">[</span><span class="n">loglikelihoods</span><span class="o">==-</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loglikelihoods</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loglikelihoods</span>

    <span class="k">def</span> <span class="nf">_generate_random_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
<span class="c1">#        return ( (self.xmin**self.beta) -</span>
<span class="c1">#            (1/self.Lambda) * log(1-r) )**(1/self.beta)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">-</span>
            <span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Truncated_Power_Law</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="s1">&#39;alpha&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span> <span class="o">=</span> <span class="s1">&#39;lambda&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;truncated_power_law&quot;</span>

    <span class="k">def</span> <span class="nf">_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">mean</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span> <span class="n">log</span><span class="p">(</span> <span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="p">))</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">&gt;</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">gammainc</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">vectorize</span>
        <span class="n">gammainc</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">gammainc</span><span class="p">)</span>

        <span class="n">CDF</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">/</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span><span class="n">CDF</span>
        <span class="k">return</span> <span class="n">CDF</span>

    <span class="k">def</span> <span class="nf">_pdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">gammainc</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">lerchphi</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">exp</span> <span class="c1"># faster /here/ than numpy.exp</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">float</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">lerchphi</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">))</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">Cxmax</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">float</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">lerchphi</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Cxmax</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">()</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
            <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">gammainc</span>
<span class="c1">#        likelihoods = (data**-alpha)*exp(-Lambda*data)*\</span>
<span class="c1">#                (Lambda**(1-alpha))/\</span>
<span class="c1">#                float(gammainc(1-alpha,Lambda*xmin))</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="n">data</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span>
                            <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span>
                            <span class="n">gammainc</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">likelihoods</span>

    <span class="k">def</span> <span class="nf">_generate_random_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
            <span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">rand</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="p">)</span><span class="o">**-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
                <span class="k">if</span> <span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">p</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">helper</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span>

<span class="k">class</span> <span class="nc">Lognormal</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="s1">&#39;mu&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span> <span class="o">=</span> <span class="s1">&#39;sigma&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;lognormal&quot;</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the probability density function (normalized histogram) of the</span>
<span class="sd">        theoretical distribution for the values in data within xmin and xmax,</span>
<span class="sd">        if present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        probabilities : array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_continuous_normalizer</span>
            <span class="k">if</span> <span class="n">C</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">f</span><span class="o">/</span><span class="n">C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_discrete_normalizer</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_discrete_normalizer</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">C</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span><span class="o">==</span><span class="s1">&#39;round&#39;</span><span class="p">:</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round_discrete_approx</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span><span class="o">==</span><span class="s1">&#39;xmax&#39;</span><span class="p">:</span>
                    <span class="n">upper_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">upper_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_approximation</span>
<span class="c1">#            from mpmath import exp</span>
                <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">upper_limit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">PDF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf_base_function</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDF</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
        <span class="k">return</span> <span class="n">likelihoods</span>

    <span class="k">def</span> <span class="nf">_round_discrete_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function reformulates the calculation to avoid underflow errors</span>
<span class="sd">        with the erf function. As implemented, erf(x) quickly approaches 1</span>
<span class="sd">        while erfc(x) is more accurate. Since erfc(x) = 1 - erf(x),</span>
<span class="sd">        calculations can be written using erfc(x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">ss</span>
        <span class="sd">&quot;&quot;&quot; Temporarily expand xmin and xmax to be able to grab the extra bit of</span>
<span class="sd">        probability mass beyond the (integer) values of xmin and xmax</span>
<span class="sd">        Note this is a design decision. One could also say this extra</span>
<span class="sd">        probability &quot;off the edge&quot; of the distribution shouldn&#39;t be included,</span>
<span class="sd">        and that implementation is retained below, commented out. Note, however,</span>
<span class="sd">        that such a cliff means values right at xmin and xmax have half the width to</span>
<span class="sd">        grab probability from, and thus are lower probability than they would otherwise</span>
<span class="sd">        be. This is particularly concerning for values at xmin, which are typically</span>
<span class="sd">        the most likely and greatly influence the distribution&#39;s fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lower_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">-.</span><span class="mi">5</span>
        <span class="n">upper_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">+.</span><span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-=</span> <span class="o">.</span><span class="mi">5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">+=</span> <span class="o">.</span><span class="mi">5</span>


        <span class="c1"># revised calculation written to avoid underflow errors</span>
        <span class="n">arg1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower_data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">arg2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper_data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">arg2</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># may still need to be fixed</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_xmin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+=.</span><span class="mi">5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-=</span> <span class="o">.</span><span class="mi">5</span>

        <span class="k">return</span> <span class="n">likelihoods</span><span class="o">/</span><span class="n">norm</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cumulative distribution function (CDF) of the lognormal</span>
<span class="sd">        distribution. Calculated for the values given in data within xmin and</span>
<span class="sd">        xmax, if present. Calculation was reformulated to avoid underflow</span>
<span class="sd">        errors</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : list or array, optional</span>
<span class="sd">            If not provided, attempts to use the data from the Fit object in</span>
<span class="sd">            which the Distribution object is contained.</span>
<span class="sd">        survival : bool, optional</span>
<span class="sd">            Whether to calculate a CDF (False) or CCDF (True).</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X : array</span>
<span class="sd">            The sorted, unique values in the data.</span>
<span class="sd">        probabilities : array</span>
<span class="sd">            The portion of the data that is less than or equal to X.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">sqrt</span>
        <span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">ss</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parent_Fit&#39;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_Fit</span><span class="o">.</span><span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_range</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">val_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">val_xmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">val_xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">val_data</span><span class="p">))</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ss</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">val_xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">:</span>
            <span class="c1"># TO DO: Improve this line further for better numerical accuracy?</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">))</span>

        <span class="n">CDF</span> <span class="o">=</span> <span class="n">CDF</span><span class="o">/</span><span class="n">norm</span>

        <span class="k">if</span> <span class="n">survival</span><span class="p">:</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">CDF</span>

        <span class="n">possible_numerical_error</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">isnan</span><span class="p">,</span> <span class="nb">min</span>
        <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">CDF</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;nan&#39; in fit cumulative distribution values.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">possible_numerical_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#if 0 in CDF or 1 in CDF:</span>
        <span class="c1">#    print(&quot;0 or 1 in fit cumulative distribution values.&quot;, file=sys.stderr)</span>
        <span class="c1">#    possible_numerical_error = True</span>
        <span class="k">if</span> <span class="n">possible_numerical_error</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Likely underflow or overflow error: the optimal fit for this distribution gives values that are so extreme that we lack the numerical precision to calculate them.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CDF</span>

    <span class="k">def</span> <span class="nf">_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">log</span>
        <span class="n">logdata</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">logdata</span><span class="p">),</span> <span class="n">std</span><span class="p">(</span><span class="n">logdata</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1">#The standard deviation can&#39;t be negative</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_cdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span>
        <span class="k">return</span>  <span class="mf">0.5</span> <span class="o">+</span> <span class="p">(</span> <span class="mf">0.5</span> <span class="o">*</span>
                <span class="n">erf</span><span class="p">((</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_pdf_base_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
        <span class="k">return</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_continuous_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">erfc</span>
<span class="c1">#        from scipy.special import erfc</span>
        <span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="k">import</span> <span class="n">pi</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">erfc</span><span class="p">((</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span> <span class="o">/</span>
             <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pdf_discrete_normalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_generate_random_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">frompyfunc</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">erf</span><span class="p">,</span> <span class="n">erfinv</span>
        <span class="c1">#This is a long, complicated function broken into parts.</span>
        <span class="c1">#We use mpmath to maintain numerical accuracy as we run through</span>
        <span class="c1">#erf and erfinv, until we get to more sane numbers. Thanks to</span>
        <span class="c1">#Wolfram Alpha for producing the appropriate inverse of the CCDF</span>
        <span class="c1">#for me, which is what we need to calculate these things.</span>
        <span class="n">erfinv</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">erfinv</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">erf</span><span class="p">(</span> <span class="p">(</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">*</span><span class="n">r</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">1.0</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">erfinv</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span>

<span class="c1">#    def _generate_random_continuous(self, r1, r2=None):</span>
<span class="c1">#        from numpy import log, sqrt, exp, sin, cos</span>
<span class="c1">#        from scipy.constants import pi</span>
<span class="c1">#        if r2==None:</span>
<span class="c1">#            from numpy.random import rand</span>
<span class="c1">#            r2 = rand(len(r1))</span>
<span class="c1">#            r2_provided = False</span>
<span class="c1">#        else:</span>
<span class="c1">#            r2_provided = True</span>
<span class="c1">#</span>
<span class="c1">#        rho = sqrt(-2.0 * self.sigma**2.0 * log(1-r1))</span>
<span class="c1">#        theta = 2.0 * pi * r2</span>
<span class="c1">#        x1 = exp(rho * sin(theta))</span>
<span class="c1">#        x2 = exp(rho * cos(theta))</span>
<span class="c1">#</span>
<span class="c1">#        if r2_provided:</span>
<span class="c1">#            return x1, x2</span>
<span class="c1">#        else:</span>
<span class="c1">#            return x1</span>


<span class="k">class</span> <span class="nc">Lognormal_Positive</span><span class="p">(</span><span class="n">Lognormal</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;lognormal_positive&quot;</span>

    <span class="k">def</span> <span class="nf">_in_standard_parameter_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1">#The standard deviation and mean can&#39;t be negative</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="nested_loglikelihood_ratio"><a class="viewcode-back" href="../index.html#powerlaw.nested_loglikelihood_ratio">[docs]</a><span class="k">def</span> <span class="nf">nested_loglikelihood_ratio</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">,</span> <span class="n">loglikelihoods2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a loglikelihood ratio and the p-value for testing which of two</span>
<span class="sd">    probability distributions is more likely to have created a set of</span>
<span class="sd">    observations. Assumes one of the probability distributions is a nested</span>
<span class="sd">    version of the other.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loglikelihoods1 : list or array</span>
<span class="sd">        The logarithms of the likelihoods of each observation, calculated from</span>
<span class="sd">        a particular probability distribution.</span>
<span class="sd">    loglikelihoods2 : list or array</span>
<span class="sd">        The logarithms of the likelihoods of each observation, calculated from</span>
<span class="sd">        a particular probability distribution.</span>
<span class="sd">    nested : bool, optional</span>
<span class="sd">        Whether one of the two probability distributions that generated the</span>
<span class="sd">        likelihoods is a nested version of the other. True by default.</span>
<span class="sd">    normalized_ratio : bool, optional</span>
<span class="sd">        Whether to return the loglikelihood ratio, R, or the normalized</span>
<span class="sd">        ratio R/sqrt(n*variance)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : float</span>
<span class="sd">        The loglikelihood ratio of the two sets of likelihoods. If positive,</span>
<span class="sd">        the first set of likelihoods is more likely (and so the probability</span>
<span class="sd">        distribution that produced them is a better fit to the data). If</span>
<span class="sd">        negative, the reverse is true.</span>
<span class="sd">    p : float</span>
<span class="sd">        The significance of the sign of R. If below a critical value</span>
<span class="sd">        (typically .05) the sign of R is taken to be significant. If above the</span>
<span class="sd">        critical value the sign of R is taken to be due to statistical</span>
<span class="sd">        fluctuations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">loglikelihood_ratio</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">,</span> <span class="n">loglikelihoods2</span><span class="p">,</span>
            <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="loglikelihood_ratio"><a class="viewcode-back" href="../index.html#powerlaw.loglikelihood_ratio">[docs]</a><span class="k">def</span> <span class="nf">loglikelihood_ratio</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">,</span> <span class="n">loglikelihoods2</span><span class="p">,</span>
        <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalized_ratio</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a loglikelihood ratio and the p-value for testing which of two</span>
<span class="sd">    probability distributions is more likely to have created a set of</span>
<span class="sd">    observations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loglikelihoods1 : list or array</span>
<span class="sd">        The logarithms of the likelihoods of each observation, calculated from</span>
<span class="sd">        a particular probability distribution.</span>
<span class="sd">    loglikelihoods2 : list or array</span>
<span class="sd">        The logarithms of the likelihoods of each observation, calculated from</span>
<span class="sd">        a particular probability distribution.</span>
<span class="sd">    nested : bool, optional</span>
<span class="sd">        Whether one of the two probability distributions that generated the</span>
<span class="sd">        likelihoods is a nested version of the other. False by default.</span>
<span class="sd">    normalized_ratio : bool, optional</span>
<span class="sd">        Whether to return the loglikelihood ratio, R, or the normalized</span>
<span class="sd">        ratio R/sqrt(n*variance)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : float</span>
<span class="sd">        The loglikelihood ratio of the two sets of likelihoods. If positive,</span>
<span class="sd">        the first set of likelihoods is more likely (and so the probability</span>
<span class="sd">        distribution that produced them is a better fit to the data). If</span>
<span class="sd">        negative, the reverse is true.</span>
<span class="sd">    p : float</span>
<span class="sd">        The significance of the sign of R. If below a critical value</span>
<span class="sd">        (typically .05) the sign of R is taken to be significant. If above the</span>
<span class="sd">        critical value the sign of R is taken to be due to statistical</span>
<span class="sd">        fluctuations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sqrt</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erfc</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">asarray</span>
    <span class="n">loglikelihoods1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">)</span>
    <span class="n">loglikelihoods2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">loglikelihoods2</span><span class="p">)</span>

    <span class="c1">#Clean for extreme values, if any</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">inf</span><span class="p">,</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">)</span>
    <span class="n">loglikelihoods1</span><span class="p">[</span><span class="n">loglikelihoods1</span><span class="o">==-</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_val</span>
    <span class="n">loglikelihoods2</span><span class="p">[</span><span class="n">loglikelihoods2</span><span class="o">==-</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_val</span>

    <span class="n">R</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="o">-</span><span class="n">loglikelihoods2</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
    <span class="n">mean_diff</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">loglikelihoods1</span><span class="p">)</span><span class="o">-</span><span class="n">mean</span><span class="p">(</span><span class="n">loglikelihoods2</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span> <span class="p">(</span><span class="n">loglikelihoods1</span><span class="o">-</span><span class="n">loglikelihoods2</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean_diff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span><span class="o">/</span><span class="n">n</span>

    <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">chi2</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfc</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">variance</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">normalized_ratio</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">variance</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span></div>

<div class="viewcode-block" id="cdf"><a class="viewcode-back" href="../index.html#powerlaw.cdf">[docs]</a><span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The cumulative distribution function (CDF) of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array, optional</span>
<span class="sd">    survival : bool, optional</span>
<span class="sd">        Whether to calculate a CDF (False) or CCDF (True). False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : array</span>
<span class="sd">        The sorted, unique values in the data.</span>
<span class="sd">    probabilities : array</span>
<span class="sd">        The portion of the data that is less than or equal to X.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cumulative_distribution_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ccdf"><a class="viewcode-back" href="../index.html#powerlaw.ccdf">[docs]</a><span class="k">def</span> <span class="nf">ccdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The complementary cumulative distribution function (CCDF) of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array, optional</span>
<span class="sd">    survival : bool, optional</span>
<span class="sd">        Whether to calculate a CDF (False) or CCDF (True). True by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : array</span>
<span class="sd">        The sorted, unique values in the data.</span>
<span class="sd">    probabilities : array</span>
<span class="sd">        The portion of the data that is less than or equal to X.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cumulative_distribution_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="cumulative_distribution_function"><a class="viewcode-back" href="../index.html#powerlaw.cumulative_distribution_function">[docs]</a><span class="k">def</span> <span class="nf">cumulative_distribution_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
    <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The cumulative distribution function (CDF) of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array, optional</span>
<span class="sd">    survival : bool, optional</span>
<span class="sd">        Whether to calculate a CDF (False) or CCDF (True). False by default.</span>
<span class="sd">    xmin : int or float, optional</span>
<span class="sd">        The minimum data size to include. Values less than xmin are excluded.</span>
<span class="sd">    xmax : int or float, optional</span>
<span class="sd">        The maximum data size to include. Values greater than xmin are</span>
<span class="sd">        excluded.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : array</span>
<span class="sd">        The sorted, unique values in the data.</span>
<span class="sd">    probabilities : array</span>
<span class="sd">        The portion of the data that is less than or equal to X.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">nan</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="n">nan</span><span class="p">])</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sort</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">all_unique</span> <span class="o">=</span> <span class="ow">not</span><span class="p">(</span> <span class="nb">any</span><span class="p">(</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">all_unique</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
<span class="c1">#This clever bit is a way of using searchsorted to rapidly calculate the</span>
<span class="c1">#CDF of data with repeated values comes from Adam Ginsburg&#39;s plfit code,</span>
<span class="c1">#specifically https://github.com/keflavich/plfit/commit/453edc36e4eb35f35a34b6c792a6d8c7e848d3b5#plfit/plfit.py</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">searchsorted</span><span class="p">,</span> <span class="n">unique</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span><span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
        <span class="n">unique_data</span><span class="p">,</span> <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="o">=</span><span class="n">unique_data</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="n">CDF</span><span class="p">[</span><span class="n">unique_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">survival</span><span class="p">:</span>
        <span class="n">CDF</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">CDF</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">CDF</span></div>

<div class="viewcode-block" id="is_discrete"><a class="viewcode-back" href="../index.html#powerlaw.is_discrete">[docs]</a><span class="k">def</span> <span class="nf">is_discrete</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if every element of the array is an integer.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">floor</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></div>

<div class="viewcode-block" id="trim_to_range"><a class="viewcode-back" href="../index.html#powerlaw.trim_to_range">[docs]</a><span class="k">def</span> <span class="nf">trim_to_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes elements of the data that are above xmin or below xmax (if present)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">asarray</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xmin</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">&gt;=</span><span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">&lt;=</span><span class="n">xmax</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="pdf"><a class="viewcode-back" href="../index.html#powerlaw.pdf">[docs]</a><span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear_bins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the probability density function (normalized histogram) of the</span>
<span class="sd">    data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array</span>
<span class="sd">    xmin : float, optional</span>
<span class="sd">        Minimum value of the PDF. If None, uses the smallest value in the data.</span>
<span class="sd">    xmax : float, optional</span>
<span class="sd">        Maximum value of the PDF. If None, uses the largest value in the data.</span>
<span class="sd">    linear_bins : float, optional</span>
<span class="sd">        Whether to use linearly spaced bins, as opposed to logarithmically</span>
<span class="sd">        spaced bins (recommended for log-log plots).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_edges : array</span>
<span class="sd">        The edges of the bins of the probability density function.</span>
<span class="sd">    probabilities : array</span>
<span class="sd">        The portion of the data that is within the bin. Length 1 less than</span>
<span class="sd">        bin_edges, as it corresponds to the spaces between them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">logspace</span><span class="p">,</span> <span class="n">histogram</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">unique</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">log10</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xmin</span><span class="p">:</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">xmin</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>  <span class="c1">#To compute the pdf also from the data below x=1, the data, xmax and xmin are rescaled dividing them by xmin.</span>
        <span class="n">xmax2</span><span class="o">=</span><span class="n">xmax</span><span class="o">/</span><span class="n">xmin</span>
        <span class="n">xmin2</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xmax2</span><span class="o">=</span><span class="n">xmax</span>
        <span class="n">xmin2</span><span class="o">=</span><span class="n">xmin</span>

    <span class="k">if</span> <span class="n">linear_bins</span><span class="p">:</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xmin2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">xmax2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_min_size</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">xmin2</span><span class="p">)</span>
        <span class="n">log_max_size</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">xmax2</span><span class="p">)</span>
        <span class="n">number_of_bins</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">log_max_size</span><span class="o">-</span><span class="n">log_min_size</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">bins</span><span class="o">=</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">floor</span><span class="p">(</span>
                    <span class="n">logspace</span><span class="p">(</span>
                        <span class="n">log_min_size</span><span class="p">,</span> <span class="n">log_max_size</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">number_of_bins</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">xmin</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1">#Needed to include also data x&lt;1 in pdf.</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="o">/</span><span class="n">xmin</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="o">*</span><span class="n">xmin</span> <span class="c1"># transform result back to original</span>
        <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="o">/</span><span class="n">xmin</span> <span class="c1"># rescale hist, so that np.sum(hist*edges)==1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edges</span><span class="p">,</span> <span class="n">hist</span></div>

<div class="viewcode-block" id="checkunique"><a class="viewcode-back" href="../index.html#powerlaw.checkunique">[docs]</a><span class="k">def</span> <span class="nf">checkunique</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Quickly checks if a sorted array is all unique elements.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>

<span class="c1">#def checksort(data):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Checks if the data is sorted, in O(n) time. If it isn&#39;t sorted, it then</span>
<span class="c1">#    sorts it in O(nlogn) time. Expectation is that the data will typically</span>
<span class="c1">#    be sorted. Presently slower than numpy&#39;s sort, even on large arrays, and</span>
<span class="c1">#    so is useless.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    n = len(data)</span>
<span class="c1">#    from numpy import arange</span>
<span class="c1">#    if not all(data[i] &lt;= data[i+1] for i in arange(n-1)):</span>
<span class="c1">#        from numpy import sort</span>
<span class="c1">#        data = sort(data)</span>
<span class="c1">#    return data</span>

<span class="k">def</span> <span class="nf">plot_ccdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">plot_cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the complementary cumulative distribution function (CDF) of the data</span>
<span class="sd">    to a new figure or to axis ax if provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array</span>
<span class="sd">    ax : matplotlib axis, optional</span>
<span class="sd">        The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">    survival : bool, optional</span>
<span class="sd">        Whether to plot a CDF (False) or CCDF (True). True by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax : matplotlib axis</span>
<span class="sd">        The axis to which the plot was made.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="plot_cdf"><a class="viewcode-back" href="../index.html#powerlaw.plot_cdf">[docs]</a><span class="k">def</span> <span class="nf">plot_cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the cumulative distribution function (CDF) of the data to a new</span>
<span class="sd">    figure or to axis ax if provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array</span>
<span class="sd">    ax : matplotlib axis, optional</span>
<span class="sd">        The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">    survival : bool, optional</span>
<span class="sd">        Whether to plot a CDF (False) or CCDF (True). False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax : matplotlib axis</span>
<span class="sd">        The axis to which the plot was made.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bins</span><span class="p">,</span> <span class="n">CDF</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">survival</span><span class="o">=</span><span class="n">survival</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">CDF</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">CDF</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="plot_pdf"><a class="viewcode-back" href="../index.html#powerlaw.plot_pdf">[docs]</a><span class="k">def</span> <span class="nf">plot_pdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear_bins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the probability density function (PDF) to a new figure or to axis ax</span>
<span class="sd">    if provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list or array</span>
<span class="sd">    ax : matplotlib axis, optional</span>
<span class="sd">        The axis to which to plot. If None, a new figure is created.</span>
<span class="sd">    linear_bins : bool, optional</span>
<span class="sd">        Whether to use linearly spaced bins (True) or logarithmically</span>
<span class="sd">        spaced bins (False). False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax : matplotlib axis</span>
<span class="sd">        The axis to which the plot was made.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span><span class="p">,</span> <span class="n">hist</span> <span class="o">=</span> <span class="n">pdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">linear_bins</span><span class="o">=</span><span class="n">linear_bins</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">nan</span>
    <span class="n">hist</span><span class="p">[</span><span class="n">hist</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="bisect_map"><a class="viewcode-back" href="../index.html#powerlaw.bisect_map">[docs]</a><span class="k">def</span> <span class="nf">bisect_map</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses binary search to find the target solution to a function, searching in</span>
<span class="sd">    a given ordered sequence of integer values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq : list or array, monotonically increasing integers</span>
<span class="sd">    function : a function that takes a single integer input, which monotonically</span>
<span class="sd">        decreases over the range of seq.</span>
<span class="sd">    target : the target value of the function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    value : the input value that yields the target solution. If there is no</span>
<span class="sd">    exact solution in the input sequence, finds the nearest value k such that</span>
<span class="sd">    function(k) &lt;= target &lt; function(k+1). This is similar to the behavior of</span>
<span class="sd">    bisect_left in the bisect package. If even the first, leftmost value of seq</span>
<span class="sd">    does not satisfy this condition, -1 is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">function</span><span class="p">([</span><span class="n">mn</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">function</span><span class="p">([</span><span class="n">mx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mx</span><span class="o">==</span><span class="n">mn</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mn</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">mn</span> <span class="o">+</span> <span class="n">mx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">function</span><span class="p">([</span><span class="n">m</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span></div>

<span class="c1">######################</span>
<span class="c1">#What follows are functional programming forms of the above code, which are more</span>
<span class="c1">#clunky and have somewhat less functionality. However, they are here if your</span>
<span class="c1">#really want them.</span>

<span class="k">class</span> <span class="nc">Distribution_Fit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete</span> <span class="o">=</span> <span class="n">discrete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span> <span class="o">=</span> <span class="n">estimate_discrete</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lognormal&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;exponential&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Lambda&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;Lambda&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;power_law&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;negative_binomial&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;stretched_exponential&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Lambda&#39;</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter3</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter1_name&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter1&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter2_name&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter2&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter3_name&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;parameter3&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;loglikelihood&#39;</span><span class="p">]:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">,</span>
                                                                   <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter3</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameter3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter3_name</span> <span class="o">=</span> <span class="n">param_names</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameters&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter1_name&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter1_name</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter2_name&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter2_name</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter3_name&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter3_name</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter1&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter2&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter2</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parameter3&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter3</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;loglikelihood&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;power_law&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">power_law_ks_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter1</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A p value outside of a loglihood ratio comparison to another candidate distribution is not currently supported.</span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                    If your data set is particularly large and has any noise in it at all, using such statistical tools as the Monte Carlo method</span><span class="se">\n\</span>
<span class="s2">                    can lead to erroneous results anyway; the presence of the noise means the distribution will obviously not perfectly fit the</span><span class="se">\n\</span>
<span class="s2">                    candidate distribution, and the very large number of samples will make the Monte Carlo simulations very close to a perfect</span><span class="se">\n\</span>
<span class="s2">                    fit. As such, such a test will always fail, unless your candidate distribution perfectly describes all elements of the</span><span class="se">\n\</span>
<span class="s2">                    system, including the noise. A more helpful analysis is the comparison between multiple, specific candidate distributions</span><span class="se">\n\</span>
<span class="s2">                    (the loglikelihood ratio test), which tells you which is the best fit of these distributions.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
<span class="c1">#</span>
<span class="c1">#        elif name in [&#39;power_law_loglikelihood_ratio&#39;,</span>
<span class="c1">#                &#39;power_law_p&#39;]:</span>
<span class="c1">#            pl_R, pl_p = distribution_compare(self.data, &#39;power_law&#39;, self.power_law.parameters, name, self.parameters, self.discrete, self.xmin, self.xmax)</span>
<span class="c1">#            self.power_law_loglikelihood_ratio = pl_R</span>
<span class="c1">#            self.power_law_p = pl_p</span>
<span class="c1">#            if name==&#39;power_law_loglikelihood_ratio&#39;:</span>
<span class="c1">#                return self.power_law_loglikelihood_ratio</span>
<span class="c1">#            if name==&#39;power_law_p&#39;:</span>
<span class="c1">#                return self.power_law_p</span>
<span class="c1">#        elif name in [&#39;truncated_power_law_loglikelihood_ratio&#39;,</span>
<span class="c1">#                &#39;truncated_power_law_p&#39;]:</span>
<span class="c1">#            tpl_R, tpl_p = distribution_compare(self.data, &#39;truncated_power_law&#39;, self.truncated_power_law.parameters, name, self.parameters, self.discrete, self.xmin, self.xmax)</span>
<span class="c1">#            self.truncated_power_law_loglikelihood_ratio = tpl_R</span>
<span class="c1">#            self.truncated_power_law_p = tpl_p</span>
<span class="c1">#            if name==&#39;truncated_power_law_loglikelihood_ratio&#39;:</span>
<span class="c1">#                return self.truncated_power_law_loglikelihood_ratio</span>
<span class="c1">#            if name==&#39;truncated_power_law_p&#39;:</span>
<span class="c1">#                return self.truncated_power_law_p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">comparison_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>

    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;negative_binomial&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_discrete</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rounding to integer values for negative binomial fit.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">around</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">around</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">discrete</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#If we aren&#39;t given an xmin, calculate the best possible one for a power law. This can take awhile!</span>
    <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xmin</span> <span class="o">==</span> <span class="s1">&#39;find&#39;</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating best minimal value&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Value 0 in data. Throwing out 0 values&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">n_tail</span><span class="p">,</span> <span class="n">noise_flag</span> <span class="o">=</span> <span class="n">find_xmin</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="n">search_method</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">,</span> <span class="n">xmin_range</span><span class="o">=</span><span class="n">xmin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;power_law&#39;</span> <span class="ow">and</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">alpha</span><span class="p">],</span> <span class="n">loglikelihood</span>

    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="c1">#Special case where we call distribution_fit multiple times to do all comparisons</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Analyzing all distributions&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating power law fit&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="n">pl_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pl_parameters</span><span class="p">,</span> <span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;power_law&#39;</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="n">search_method</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;discrete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">discrete</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fits&#39;</span><span class="p">][</span><span class="s1">&#39;power_law&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pl_parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating truncated power law fit&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">tpl_parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">comparison_alpha</span><span class="o">=</span><span class="n">pl_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_method</span><span class="o">=</span><span class="n">search_method</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fits&#39;</span><span class="p">][</span><span class="s1">&#39;truncated_power_law&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tpl_parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;power_law_comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;power_law_comparison&#39;</span><span class="p">][</span><span class="s1">&#39;truncated_power_law&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;truncated_power_law_comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">supported_distributions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">,</span> <span class="s1">&#39;stretched_exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">supported_distributions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating </span><span class="si">%s</span><span class="s2"> fit&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">comparison_alpha</span><span class="o">=</span><span class="n">pl_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_method</span><span class="o">=</span><span class="n">search_method</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fits&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;power_law_comparison&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

            <span class="n">R</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">distribution_compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">,</span> <span class="n">tpl_parameters</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;truncated_power_law_comparison&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="c1">#Handle edge case where we don&#39;t have enough data</span>
    <span class="n">no_data</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">((</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)):</span>
        <span class="c1">#Everything is beyond the bounds of the xmax and xmin</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">):</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">no_data</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;Likelihood&#39;</span><span class="p">:</span>
            <span class="n">loglikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">max_10_exp</span>
        <span class="k">if</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;KS&#39;</span><span class="p">:</span>
            <span class="n">loglikelihood</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">comparison_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span>
        <span class="n">R</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">max_10_exp</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="c1">#Initial search parameters, estimated from the data</span>
<span class="c1">#    print(&quot;Calculating initial parameters for search&quot;, file=sys.stderr)</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;power_law&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmin</span><span class="p">)))]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;exponential&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;stretched_exponential&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">)),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span>
        <span class="n">logdata</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean</span><span class="p">(</span><span class="n">logdata</span><span class="p">),</span> <span class="n">std</span><span class="p">(</span><span class="n">logdata</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;negative_binomial&#39;</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">mean</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">)),</span> <span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;Likelihood&#39;</span><span class="p">:</span>
<span class="c1">#        print(&quot;Searching using maximum likelihood method&quot;, file=sys.stderr)</span>
        <span class="c1">#If the distribution is a continuous power law without an xmax, and we&#39;re using the maximum likelihood method, we can compute the parameters and likelihood directly</span>
        <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;power_law&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">discrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">nan</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span>\
                <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">))</span>
            <span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">loglikelihood</span> <span class="o">==</span> <span class="n">nan</span><span class="p">:</span>
                <span class="n">loglikelihood</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span>
        <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;power_law&#39;</span> <span class="ow">and</span> <span class="n">discrete</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">alpha</span> <span class="ow">and</span> <span class="n">estimate_discrete</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">nan</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span>\
                <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="p">)))</span>
            <span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">loglikelihood</span> <span class="o">==</span> <span class="n">nan</span><span class="p">:</span>
                <span class="n">loglikelihood</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span>

        <span class="c1">#Otherwise, we set up a likelihood function</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="n">likelihood_function_generator</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">)</span>

        <span class="c1">#Search for the best fit parameters for the target distribution, on this data</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin</span>
        <span class="n">parameters</span><span class="p">,</span> <span class="n">negative_loglikelihood</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">funcalls</span><span class="p">,</span> <span class="n">warnflag</span><span class="p">,</span> <span class="o">=</span> \
            <span class="n">fmin</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">likelihood_function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">data</span><span class="p">))),</span>
                <span class="n">initial_parameters</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">loglikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="n">negative_loglikelihood</span>

        <span class="k">if</span> <span class="n">comparison_alpha</span><span class="p">:</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">distribution_compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;power_law&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">comparison_alpha</span><span class="p">],</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">loglikelihood</span>

    <span class="k">elif</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;KS&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not yet supported. Sorry.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">return</span>
<span class="c1">#        #Search for the best fit parameters for the target distribution, on this data</span>
<span class="c1">#        from scipy.optimize import fmin</span>
<span class="c1">#        parameters, KS, iter, funcalls, warnflag, = \</span>
<span class="c1">#                fmin(\</span>
<span class="c1">#                lambda p: -sum(log(likelihood_function(p, data))),\</span>
<span class="c1">#                initial_parameters, full_output=1, disp=False)</span>
<span class="c1">#        loglikelihood =-negative_loglikelihood</span>
<span class="c1">#</span>
<span class="c1">#        if comparison_alpha:</span>
<span class="c1">#            R, p = distribution_compare(data, &#39;power_law&#39;,[comparison_alpha], distribution, parameters, discrete, xmin, xmax)</span>
<span class="c1">#            return parameters, loglikelihood, R, p</span>
<span class="c1">#        else:</span>
<span class="c1">#            return parameters, loglikelihood</span>


<span class="k">def</span> <span class="nf">distribution_compare</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">distribution1</span><span class="p">,</span> <span class="n">parameters1</span><span class="p">,</span>
                         <span class="n">distribution2</span><span class="p">,</span> <span class="n">parameters2</span><span class="p">,</span>
                         <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">no_data</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">((</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)):</span>
        <span class="c1">#Everything is beyond the bounds of the xmax and xmin</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">):</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">no_data</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span>

    <span class="n">likelihood_function1</span> <span class="o">=</span> <span class="n">likelihood_function_generator</span><span class="p">(</span><span class="n">distribution1</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
    <span class="n">likelihood_function2</span> <span class="o">=</span> <span class="n">likelihood_function_generator</span><span class="p">(</span><span class="n">distribution2</span><span class="p">,</span> <span class="n">discrete</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

    <span class="n">likelihoods1</span> <span class="o">=</span> <span class="n">likelihood_function1</span><span class="p">(</span><span class="n">parameters1</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">likelihoods2</span> <span class="o">=</span> <span class="n">likelihood_function2</span><span class="p">(</span><span class="n">parameters2</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">distribution1</span> <span class="ow">in</span> <span class="n">distribution2</span><span class="p">)</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">distribution2</span> <span class="ow">in</span> <span class="n">distribution1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">nested</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assuming nested distributions&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">loglikelihood_ratio</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">likelihoods1</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">likelihoods2</span><span class="p">),</span>
                               <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">likelihood_function_generator</span><span class="p">(</span><span class="n">distribution_name</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;power_law&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">power_law_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;exponential&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">exponential_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;stretched_exponential&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">stretched_exponential_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;truncated_power_law&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">truncated_power_law_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">lognormal_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;negative_binomial&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">negative_binomial_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distribution_name</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="n">likelihood_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span>\
            <span class="n">gamma_likelihoods</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">likelihood_function</span>

<span class="k">def</span> <span class="nf">find_xmin</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xmin_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sort</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">argmin</span><span class="p">,</span> <span class="n">vstack</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">sqrt</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Value 0 in data. Throwing out 0 values&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>
<span class="c1">#Much of the rest of this function was inspired by Adam Ginsburg&#39;s plfit code, specifically around lines 131-143 of this version: http://code.google.com/p/agpy/source/browse/trunk/plfit/plfit.py?spec=svn359&amp;r=357</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xmin_range</span> <span class="o">==</span> <span class="s1">&#39;find&#39;</span> <span class="ow">or</span> <span class="n">xmin_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">possible_xmins</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">possible_xmins</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin_range</span><span class="p">)]</span>
        <span class="n">possible_xmins</span> <span class="o">=</span> <span class="n">possible_xmins</span><span class="p">[</span><span class="n">possible_xmins</span> <span class="o">&gt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin_range</span><span class="p">)]</span>
    <span class="n">xmins</span><span class="p">,</span> <span class="n">xmin_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">possible_xmins</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">xmins</span> <span class="o">=</span> <span class="n">xmins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xmins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loglikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">max_10_exp</span>
        <span class="n">n_tail</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Ds</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">n_tail</span><span class="p">,</span> <span class="n">noise_flag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">n_tail</span><span class="p">,</span> <span class="n">noise_flag</span><span class="p">,</span> <span class="n">xmins</span><span class="p">,</span> <span class="n">Ds</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">sigmas</span>

    <span class="n">xmin_indices</span> <span class="o">=</span> <span class="n">xmin_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Don&#39;t look at last xmin, as that&#39;s also the xmax, and we want to at least have TWO points to fit!</span>

    <span class="k">if</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;Likelihood&#39;</span><span class="p">:</span>
        <span class="n">alpha_MLE_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xmin</span><span class="p">:</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;power_law&#39;</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">)</span>
        <span class="n">fits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">alpha_MLE_function</span><span class="p">,</span> <span class="n">xmins</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">search_method</span> <span class="o">==</span> <span class="s1">&#39;KS&#39;</span><span class="p">:</span>
        <span class="n">alpha_KS_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xmin</span><span class="p">:</span> <span class="n">distribution_fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;power_law&#39;</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">,</span> <span class="n">search_method</span><span class="o">=</span><span class="s1">&#39;KS&#39;</span><span class="p">,</span> <span class="n">estimate_discrete</span><span class="o">=</span><span class="n">estimate_discrete</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">alpha_KS_function</span><span class="p">,</span> <span class="n">xmins</span><span class="p">)))</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">alphas</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">loglikelihoods</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">ks_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">index</span><span class="p">:</span> <span class="n">power_law_ks_distance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">xmins</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">)</span>
    <span class="n">Ds</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ks_function</span><span class="p">,</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xmins</span><span class="p">)))))</span>

    <span class="n">sigmas</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphas</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">xmin_indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">good_values</span> <span class="o">=</span> <span class="n">sigmas</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">1</span>
    <span class="c1">#Find the last good value (The first False, where sigma &gt; .1):</span>
    <span class="n">xmin_max</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">good_values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">good_values</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># If there are no fits beyond the noise threshold</span>
        <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">Ds</span><span class="p">)</span>
        <span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">xmin_max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">Ds</span><span class="p">[:</span><span class="n">xmin_max</span><span class="p">])</span>
        <span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_D_index</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">Ds</span><span class="p">)</span>
        <span class="n">noise_flag</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmins</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Ds</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">alphas</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
    <span class="n">loglikelihood</span> <span class="o">=</span> <span class="n">loglikelihoods</span><span class="p">[</span><span class="n">min_D_index</span><span class="p">]</span>
    <span class="n">n_tail</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">n_tail</span><span class="p">,</span> <span class="n">noise_flag</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">loglikelihood</span><span class="p">,</span> <span class="n">n_tail</span><span class="p">,</span> <span class="n">noise_flag</span><span class="p">,</span> <span class="n">xmins</span><span class="p">,</span> <span class="n">Ds</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">sigmas</span>


<span class="k">def</span> <span class="nf">power_law_ks_distance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kuiper</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">mean</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kuiper</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">Theoretical_CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">zeta</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">bins</span><span class="p">,</span> <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="n">cumulative_distribution_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">)</span>
            <span class="n">Theoretical_CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span>\
                    <span class="p">(</span><span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span><span class="o">-</span><span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">bins</span><span class="p">,</span> <span class="n">Actual_CDF</span> <span class="o">=</span> <span class="n">cumulative_distribution_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">)</span>
            <span class="n">Theoretical_CDF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="o">/</span>\
                    <span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">))</span>

    <span class="n">D_plus</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Theoretical_CDF</span> <span class="o">-</span> <span class="n">Actual_CDF</span><span class="p">)</span>
    <span class="n">D_minus</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Actual_CDF</span> <span class="o">-</span> <span class="n">Theoretical_CDF</span><span class="p">)</span>
    <span class="n">Kappa</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mean</span><span class="p">(</span><span class="n">Theoretical_CDF</span> <span class="o">-</span> <span class="n">Actual_CDF</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kuiper</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">D_plus</span><span class="p">,</span> <span class="n">D_minus</span><span class="p">,</span> <span class="n">Kappa</span>

    <span class="n">D</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">D_plus</span><span class="p">,</span> <span class="n">D_minus</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">D</span>


<span class="k">def</span> <span class="nf">power_law_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span>\
                      <span class="p">((</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xmin</span> <span class="o">**</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
            <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">zeta</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span>\
                <span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">zeta</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span>\
                          <span class="p">(</span><span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeta</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">negative_binomial_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="c1">#Better to make this correction earlier on in distribution_fit, so as to not recheck for discreteness and reround every time fmin is used.</span>
    <span class="c1">#if not is_discrete(data):</span>
    <span class="c1">#    print(&quot;Rounding to nearest integer values for negative binomial fit.&quot;, file=sys.stderr)</span>
    <span class="c1">#    from numpy import around</span>
    <span class="c1">#    data = around(data)</span>

    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">asarray</span>
    <span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="k">import</span> <span class="n">comb</span>
    <span class="n">pmf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="n">r</span> <span class="o">*</span> <span class="n">p</span> <span class="o">**</span> <span class="n">k</span>
    <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">xmin</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
        <span class="n">normalization_constant</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">likelihoods</span> <span class="o">/</span> <span class="n">normalization_constant</span>

    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">exponential_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Lambda</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
<span class="c1">#        likelihoods = exp(-Lambda*data)*\</span>
<span class="c1">#                Lambda*exp(Lambda*xmin)</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">data</span><span class="p">))</span>  <span class="c1"># Simplified so as not to throw a nan from infs being divided by each other</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="o">*</span>\
                             <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span><span class="p">))</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span><span class="p">))</span>\
                <span class="o">/</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">stretched_exponential_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">Lambda</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
<span class="c1">#        likelihoods = (data**(beta-1) * exp(-Lambda*(data**beta)))*\</span>
<span class="c1">#            (beta*Lambda*exp(Lambda*(xmin**beta)))</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">data</span> <span class="o">**</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">**</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">data</span> <span class="o">**</span> <span class="n">beta</span><span class="p">))</span>  <span class="c1"># Simplified so as not to throw a nan from infs being divided by each other</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="n">X</span> <span class="o">**</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">**</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">X</span> <span class="o">**</span> <span class="n">beta</span><span class="p">))</span>  <span class="c1"># Simplified so as not to throw a nan from infs being divided by each other</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="n">PDF</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">gamma_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
    <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">gammainc</span>
<span class="c1">#    from scipy.special import gamma, gammainc #Not NEARLY numerically accurate enough for the job</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>
        <span class="c1">#Calculate how much probability mass is beyond xmin, and normalize by it</span>
        <span class="n">normalization_constant</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span> <span class="o">/</span> <span class="n">theta</span><span class="p">,</span> <span class="n">regularized</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># Mpmath&#39;s regularized option divides by gamma(k)</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">likelihoods</span> <span class="o">/</span> <span class="n">normalization_constant</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="n">PDF</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">truncated_power_law_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Lambda</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">gammainc</span>
<span class="c1">#        from scipy.special import gamma, gammaincc #Not NEARLY accurate enough to do the job</span>
<span class="c1">#        likelihoods = (data**-alpha)*exp(-Lambda*data)*\</span>
<span class="c1">#                (Lambda**(1-alpha))/\</span>
<span class="c1">#                float(gammaincc(1-alpha,Lambda*xmin))</span>
        <span class="c1">#Simplified so as not to throw a nan from infs being divided by each other</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lambda</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">/</span>\
                      <span class="p">((</span><span class="n">data</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">gammainc</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Lambda</span> <span class="o">*</span> <span class="n">xmin</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">**</span> <span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="n">PDF</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>


<span class="k">def</span> <span class="nf">lognormal_likelihoods</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">log</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mu</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
        <span class="c1">#The standard deviation can&#39;t be negative, and the mean of the logarithm of the distribution can&#39;t be smaller than the log of the smallest member of the distribution!</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">tile</span>
        <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">xmin</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">exp</span>
<span class="c1">#        from mpmath import erfc</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erfc</span>
        <span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="k">import</span> <span class="n">pi</span>
        <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span>\
            <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">erfc</span><span class="p">((</span><span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">))</span>
<span class="c1">#        likelihoods = likelihoods.astype(float)</span>
    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmax</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">exp</span>
<span class="c1">#            from mpmath import exp</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">#            PDF_function = lambda x: (1.0/x)*exp(-( (log(x) - mu)**2 ) / 2*sigma**2)</span>
<span class="c1">#            PDF = asarray(list(map(PDF_function,X)))</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">log</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">PDF</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDF</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">PDF</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">likelihoods</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">[(</span><span class="n">data</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">float_info</span>
    <span class="n">likelihoods</span><span class="p">[</span><span class="n">likelihoods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">float_info</span><span class="o">.</span><span class="n">min_10_exp</span>
    <span class="k">return</span> <span class="n">likelihoods</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2013-2017, Jeff Alstott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>